<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.png"> <title>PE problem 1</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p> Small dirty beans... of course we talkin' about coffe. </> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class="sidebar-nav-item " href="/menu1/">Code blocks</a> <a class="sidebar-nav-item " href="/menu2/">More goodies</a> <a class="sidebar-nav-item " href="/menu3/">Tags</a> <a class="sidebar-nav-item " href="/menu-coding/">Coding</a> </nav> <div class=sidebar-item > <p>&copy; Flores-Torres Leonardo.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home > QuantumBeans </a> <small> Are we quantum yet? [No...] Then, can I get some coffee? </small> </h3> </div> </div> <div class="container content"> <div class=franklin-content > <h1 id=project_euler_problem_001 ><a href="#project_euler_problem_001" class=header-anchor >Project Euler problem 001</a></h1> <p>The statement to the first problem is as follows:</p> <div class=colbox-blue ><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p> <p>Find the sum of all the multiples of 3 or 5 below 1000.</p></div> <h2 id=hands-on ><a href="#hands-on" class=header-anchor >Hands-on</a></h2> <p>I am trying to use a <code>lisp</code> dialect, specifically, <code>racket</code>. I was wondering if I should have started with <code>common lisp</code> but I believe that <code>racket</code> is a good starting point.</p> <p>I&#39;ll start by breaking the problem into parts. The first part being to determine if a given number <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is multiple of 3 and 5. To know if a number is multiple of another one can just compute the modulo <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mspace></mspace><mspace width=0.4444em /><mo stretchy=false >(</mo><mrow><mi mathvariant=normal >m</mi><mi mathvariant=normal >o</mi><mi mathvariant=normal >d</mi></mrow><mspace width=0.3333em /><mi>m</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">n \pmod m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace allowbreak"></span><span class=mspace  style="margin-right:0.4444em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord ><span class=mord ><span class="mord mathrm">mod</span></span></span><span class=mspace  style="margin-right:0.3333em;"></span><span class="mord mathnormal">m</span><span class=mclose >)</span></span></span></span>, if it equals 0 then <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is a multiple of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.6444em;"></span><span class=mord >3</span></span></span></span>.</p> <p>I wrote one function for each case:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >multiple-of-3?</span> n)
  (<span class=hljs-name ><span class=hljs-built_in >=</span></span> 
    (<span class=hljs-name ><span class=hljs-built_in >modulo</span></span> n <span class=hljs-number >3</span>)
    <span class=hljs-number >0</span>))

(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >multiple-of-5?</span> n) 
  (<span class=hljs-name ><span class=hljs-built_in >=</span></span>
    (<span class=hljs-name ><span class=hljs-built_in >modulo</span></span> n <span class=hljs-number >5</span>)
    <span class=hljs-number >0</span>))</code></pre> <p>Now, with a way to determine if a given number <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is multiple of 3 or 5, it is possible to write a recursive function to sum all numbers in the range <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo separator=true >,</mo><mi>s</mi><mi>t</mi><mi>o</mi><mi>p</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">[start,stop)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span><span class="mord mathnormal">p</span><span class=mclose >)</span></span></span></span> as long as both conditions are met. The right-side of the range is not included because the statement of the problem mentions that the sum only includes the numbers below a limit.</p> <p>The function <code>sum-of-multiples</code> has 3 arguments, the starting and ending points of the sum, <code>start</code> and <code>stop</code>, respectively, and an optional argument <code>acc</code> which is an accumulator where the sum of those numbers that are multiples of 3 and 5 are added up:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> start stop [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >and</span></span>
           (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >multiple-of-3?</span> start))
           (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >multiple-of-5?</span> start)))
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <p>On each recursion, the value of <code>start</code> is modified adding 1 to it as to <em>emulate</em> the iteration process done in not-functional programming languages. Only when the condition is fulfilled is when the value of the accumulator <code>acc</code> is updated on the following call to <code>sum-of-multiples</code>.</p> <p>By this point I noticed something seemed weird in the structure of <code>sum-of-multiples</code>, the logic was a little bit messy. Even though the result of evaluating the function with the test case gave the correct result:</p> <pre><code class="scheme hljs">&gt; (<span class=hljs-name >sum-of-multiples</span> <span class=hljs-number >0</span> <span class=hljs-number >10</span>)
<span class=hljs-number >23</span></code></pre> <p>Let us compute the solution to the problem before refactoring the functions:</p> <pre><code class="scheme hljs">&gt; (<span class=hljs-name >sum-of-multiples</span> <span class=hljs-number >1</span> <span class=hljs-number >1000</span>)
<span class=hljs-number >233168</span></code></pre> <p>The first change is to remove the explicit dependency of <code>sum-of-multiples</code> changing <code>start</code> to be an optional argument, and declaring it to start at 1 instead of 0:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> stop [<span class=hljs-name >start</span> <span class=hljs-number >0</span>] [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >and</span></span>
           (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >multiple-of-3?</span> start))
           (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >multiple-of-5?</span> start)))
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <p>Now, allow me to give the propositional logic another look...</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mo stretchy=false >(</mo><mi mathvariant=normal >¬</mi><mi>a</mi><mo stretchy=false >)</mo><mo>∧</mo><mo stretchy=false >(</mo><mi mathvariant=normal >¬</mi><mi>b</mi><mo stretchy=false >)</mo><mo>⇔</mo><mi mathvariant=normal >¬</mi><mo stretchy=false >(</mo><mi>a</mi><mo>∨</mo><mi>b</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> (\neg a) \land (\neg b) \Leftrightarrow \neg (a \lor b) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >¬</span><span class="mord mathnormal">a</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∧</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >(</span><span class=mord >¬</span><span class="mord mathnormal">b</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2778em;"></span><span class=mrel >⇔</span><span class=mspace  style="margin-right:0.2778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >¬</span><span class=mopen >(</span><span class="mord mathnormal">a</span><span class=mspace  style="margin-right:0.2222em;"></span><span class=mbin >∨</span><span class=mspace  style="margin-right:0.2222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class=mclose >)</span></span></span></span></span> <p>okay so I was right but I can make it neater. And <code>sum-of-multiples</code> will look like</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> stop [<span class=hljs-name >start</span> <span class=hljs-number >0</span>] [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name ><span class=hljs-built_in >or</span></span> (<span class=hljs-name >multiple-of-3?</span> start) (<span class=hljs-name >multiple-of-5?</span> start)))
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <p>I still don&#39;t like to have two functions that do se same thing <code>multiple-of-3?</code> and <code>multiple-of-5?</code>. One single function could do the trick:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >is-multiple?</span> x y)
  (<span class=hljs-name ><span class=hljs-built_in >=</span></span>
   (<span class=hljs-name ><span class=hljs-built_in >modulo</span></span> x y)
   <span class=hljs-number >0</span>))</code></pre> <p>With this change, the function <code>sum-of-multiples</code> will look as</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> stop [<span class=hljs-name >start</span> <span class=hljs-number >0</span>] [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name ><span class=hljs-built_in >or</span></span> (<span class=hljs-name >is-multiple?</span> start <span class=hljs-number >3</span>) (<span class=hljs-name >is-multiple?</span> start <span class=hljs-number >5</span>)))
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <p>... and I think it is beautiful.</p> <p>Testing it with the test case and the problem case we get the same results:</p> <pre><code class="scheme hljs">&gt; (<span class=hljs-name >sum-of-multiples</span> <span class=hljs-number >10</span>)
<span class=hljs-number >23</span>
&gt; (<span class=hljs-name >sum-of-multiples</span> <span class=hljs-number >1000</span>)
<span class=hljs-number >233168</span></code></pre> <p>In <code>racket</code> there is a function very handy to remove the two calls of <code>is-multiple?</code> inside the <code>or</code>, it is <code>ormap</code>. For example, the function <code>is-multiple?</code> can be mapped to the elements of a list, in this case 3 and 5, to know if a given number is multiple of each of them individually:</p> <pre><code class="scheme hljs">&gt; (<span class=hljs-name ><span class=hljs-built_in >map</span></span> (<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x)
	(<span class=hljs-name >is-multiple?</span> <span class=hljs-number >6</span> x)) &#x27;(<span class=hljs-number >3</span> <span class=hljs-number >5</span>))
&#x27;(<span class=hljs-literal >#t</span> <span class=hljs-literal >#f</span>)</code></pre> <p>Clearly, 6 is multiple of 3 but not of 5. But it is only necessary that the number we are testing, in this case is 6, is multiple of one of them not all. This is were <code>ormap</code> is helpful, the documentation explains that <code>&#40;ormap f &#40;list x y z&#41;&#41;</code> is equivalent to <code>&#40;or &#40;f x&#41; &#40;f y&#41; &#40;f z&#41;&#41;</code> where <code>f</code> is a function and <code>x, y, z</code> are arguments to be applied to that function. Thus, the refactoring will lead to:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> stop [<span class=hljs-name >start</span> <span class=hljs-number >0</span>] [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >ormap</span> (<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x)
                        (<span class=hljs-name >is-multiple?</span> start x)) &#x27;(<span class=hljs-number >3</span> <span class=hljs-number >5</span>)))
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <p>And the function can be made more generic is a new argument is provided to hold the list of factors:</p> <pre><code class="scheme hljs">(<span class=hljs-name ><span class=hljs-built_in >define</span></span> (<span class=hljs-name >sum-of-multiples</span> factors stop [<span class=hljs-name >start</span> <span class=hljs-number >0</span>] [<span class=hljs-name >acc</span> <span class=hljs-number >0</span>])
  (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >=</span></span> start stop)
      acc
      (<span class=hljs-name ><span class=hljs-built_in >if</span></span> (<span class=hljs-name ><span class=hljs-built_in >not</span></span> (<span class=hljs-name >ormap</span> (<span class=hljs-name ><span class=hljs-built_in >lambda</span></span> (x)
                        (<span class=hljs-name >is-multiple?</span> start x)) factors))
          (<span class=hljs-name >sum-of-multiples</span> factors stop (<span class=hljs-name >add1</span> start) acc)
          (<span class=hljs-name >sum-of-multiples</span> factors stop (<span class=hljs-name >add1</span> start) (<span class=hljs-name ><span class=hljs-built_in >+</span></span> acc start)))))</code></pre> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Flores-Torres Leonardo. Last modified: April 12, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script> <label for=sidebar-checkbox  class=sidebar-toggle ></label>